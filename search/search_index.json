{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"delphi Documentation for relevant repositories to DRIFT's 2023-2024 project: LEADS. Table of Contents Project Original Repository MkDocs Documentation telemetry-stream Link Link ardupilot-logs-parsing Link Link kinematic-model Link Link PTU-SDK \ud83d\udeab Link team-drift.org \ud83d\udeab Work in progress","title":"Home"},{"location":"#delphi","text":"Documentation for relevant repositories to DRIFT's 2023-2024 project: LEADS.","title":"delphi"},{"location":"#table-of-contents","text":"Project Original Repository MkDocs Documentation telemetry-stream Link Link ardupilot-logs-parsing Link Link kinematic-model Link Link PTU-SDK \ud83d\udeab Link team-drift.org \ud83d\udeab Work in progress","title":"Table of Contents"},{"location":"PTU-SDK/","text":"PTU-SDK PTU-SDK is an SDK provided by FLIR -- with additional utilities/wrappers written by DRIFT -- necessary to control the gimbal. In this documentation, we outline the PTU-SDK works and how to use it. Project Stack This project is written in the C++17 standard, and utilizes the following components: FLiR Base PTU-SDK - The base sdk as provided by FLiR, which facilitates low-level communication with the gimbal FLiR Cerial Library - A networking library used by the base sdk PyBind11 - A library for easily creating python bindings for C++ Python Setuptools - A python build system for creating python modules from this project CMake - Building all components of the sdk clang-tidy - Checks and linting to ensure code quality clang-format - Formatting rules for the project gcc/clang - Either compiler can be utilized depending on developer preference Of these components, CMake, gcc/clang, and Python are REQUIRED for building this project! The rest are either provided with the project, or are optional. Project Structure This section describes the outline of the project, which includes the physical layout of the project files, CMake build targets, and how components in this project interact. File Structure This project has the following outline: PTU-SDK/ \u251c\u2500\u2500 build \u251c\u2500\u2500 dist \u251c\u2500\u2500 docs \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 dptu \u251c\u2500\u2500 libs \u2502 \u2514\u2500\u2500 ptu-sdk \u2502 \u2514\u2500\u2500 cerial \u251c\u2500\u2500 python \u2502 \u2514\u2500\u2500 pdptu \u251c\u2500\u2500 src \u2514\u2500\u2500 utils \u251c\u2500\u2500 drift \u2514\u2500\u2500 sdk-examples Some of these directories will NOT be included in version control, so they may not be present in a fresh clone. All these directories will be auto-generated in one way or another if you preform the operations outlined in the documentation. Directories not included in version control are: build - CMake generated build files, your final build binaries will be placed here when building with CMake! dist - Final Python source distributions / wheels that are built via setuptools The other directories are described below: docs - Contains documentation for this project include - Header files for custom libraries created for this project dptu - header files for the drift PTU sdk src - Source files for custom libraries created for this project python - Python bindings for the drift PTU sdk utils - Development/testing utilities to simplify certain gimbal operations drift - Utilities produced by drift sdk-examples - Utilities provided with the base sdk, these are unaltered libs - External libraries vendored with this project. Required for building any project components ptu-sdk - The provided base sdk, mostly unaltered cerial - 'Cerial' library utilized by the base sdk, mostly unaltered The directories to keep in mind are include/ , src/ , and utils/drift . All others are either automatically generated or are not meant to be changed, as we are striving to keep the provided base components static as much as possible. Any new components and alterations can be be done in the three directories specified most of the time! CMake Structure This project uses CMake in all build scenarios! All components in this project are CMake enabled, allowing most operations to be done via CMake. This project defines many targets that can be built, but most of the time you only want to focus on a few Below is a outline of the targets, children of a target depends on them: cerial \u2514\u2500\u2500 ptusdk \u251c\u2500\u2500 dptu \u2502 \u251c\u2500\u2500 driftutil \u2502 \u2514\u2500\u2500 pdptu \u2514\u2500\u2500 sdkexamples cerial - Networking library required by the base sdk ptusdk - Provided base sdk library sdkexamples - Builds ALL provided base sdk example binaries, can be executed dptu - DRIFT wrapper library around the base sdk driftutil - Builds ALL DRIFT utility binaries, can be executed pdptu - Python bindings for dptu as a shared library. Building this yourself is usually not required, see the python section CMake As mentioned earlier in this document, this project is build via CMake . It is recommended to handle this process through your IDE, but it is possible to do so manually. Build Steps: Create a build directory: mkdir build Navigate to build directory: cd build/ Invoke CMake to configure the project: cmake .. After the project has been configured, you will see the build directory has been populated with many files! Pretty much all of these can be ignored, but later down the line we will outline some files that are relevant. Build your target: make [TARGET] Where [TARGET] is the name of the target you wish to build. You can see a list of targets above in the CMake Structure section. For example, if you wish to build the dptu target: make dptu Any dependencies will be automatically built for you, so don't worry about building any parents. Locate your build If you are building a library, it will be in format .a for a static library, or .so for a shared library. Unless you are building the python bindings, all libraries built by this project are static, and will have filetype .a . Executables have varying filetypes. On Unix like systems, they will not have a file extension. On Windows, they will have a .exe extension. CMake organizes the build directory in the same way the project is structured. This means it places binaries in locations that are comparable to that of the project. For example, if you build the demo executable, you can find it in: build/utils/drift/demo The same goes for other components, simply follow the directories to locate your binary. Once you have located your binary, you can move it to wherever you like! From there, you can utilize it as you see fit. If you experience any strange errors, or mess up the state of the build system, then you can safely delete the build directory and restart. The build directory does not contain any valuable information! So deleting and reconfiguring has no large consequences, other than the time that is required to re-create and re-build any components. Python This project also contains Python bindings that allow this code to be worked with and utilized in Python! This is done via PyBind11 , which greatly simplifies this procedure. PyBind11 is automatically fetched by CMake at configure time, so it is not necessary to install this dependency system wide! Here are the steps to build the python module: First, create a python virtual environment: python -m venv venv/ Activate the virtual environment: source venv/bin/activate Next, install build tools: pip install build Invoke the build system: python -m build From here, it will build your python module and place it into the dist/ directory. This command will create two types of distributions, which we will cover below. Source Distribution A source distribution is a Python package that contains the files necessary to build your Python module. When asked to install this package, Python will use the contents to build the module for the system it is running on. This is the recommended way to distribute the Python module! It is best to have other developers build the module from scratch on their own systems, instead of having to worry about platform differences and cross-compilation. The downside to this approach is that source distributions require extra time to install on the end of the receiver, as they will need to build the module themselves. This will also require the receiver to have build tools installed, such as CMake and a compiler (gcc/clang), which may be trivial or very difficult to install depending on your platform. Source distributions have extension of type .tar.gz Wheel Distribution A so-called 'wheel' is a type of Python package that contains a pre-built module. Wheels are very useful as they do not require a build operation before installing, so any receivers of the wheel can utilize the package immediately and do not require any build tools to be installed. The downside is that the wheel can only be used on the platform it was built on. For example, if a wheel is built on Linux, it is only possible to install and use the wheel on Linux platforms. A windows user could not use such a wheel. While it is possible to cross-build wheels for other platforms, it is not recommended to do so as this introduces a lot of complexity. So, you probably will not be distributing the wheel to others. Wheel distributions have extension of type .whl Development Environment Developers may work on the project using any tools they like! It is possible to work with this project with nothing more than a text editor, given that you have the requirements satisfied in the tech stack portion of this document. However, this is not recommended, so we will provide a minimum development environment recommendation VSCode is the recommended IDE for this project! It is highly configurable and offers all the features you could want. Any IDE that has support for C++ and CMake would suffice (such as CLion), but we will focus on VSCode in this section. Alongside VSCode, you will want the following extensions: C/C++ - Enables C/C++ Development in VSCode CMake Tools - Adds support for CMake enabled projects Doxygen Generator - Simplifies the process of creating doxygen documentation These extensions are the bare minimum, and it is recommended to install other extensions that enhance your workflow, such as the GitHub integration extension. Alongside these extensions, we suggest the following changes: C_Cpp.codeAnalysis.clangTidy.enabled = true - Enables clang-tidy checks to be preformed by VSCode C_Cpp.codeAnalysis.clangTidy.useBuildPath = true - Instructs clang-tidy to utilize CMake compile-commands.json This will allow VSCode to build and analyze this project for you! Code Components This section will describe the files that make up this project. Most of the code is already documented in the source! All functions/components have docstrings that describe their usage and behavior, and all code is well commented. However, this section will offer a high level view of the codebase. This project uses the conventional C++ project format, a collection of header files that each have a source file. The header files each contain components that do a specific thing. We will go over each file and go over the broad details: include/ \u2514\u2500\u2500 dptu \u251c\u2500\u2500 comwrap.hpp \u251c\u2500\u2500 entry.hpp \u251c\u2500\u2500 init.hpp \u2514\u2500\u2500 trans.hpp init The init.hpp header contains components for creating and destroying a 'harness', which is a structure that contains the necessary information for communicating with the gimbal. The nature of this structure will not be discussed here (you may look into the base SDK code if you are curious), as it is not important for gimbal usage. The creation process, done via init_harness() will allocate and configure the harness for operation. The destruction process, done via close_harness() will close the harness and free any memory. It is REQUIRED for all operations to use these methods for creating and destroying the harness! Failing to do either operations can cause bugs and trouble! Most features the DRIFT wrapper provides are optional and can be ignored, but this operation is required! comwrap The comwrap.hpp header contains components for wrapping certain SDK operations. The procedure for sending a command to the gimbal via the base sdk is somewhat complicated and weird. So, one of the major goals of this project is to simplify operations and this header defines components that do just that. Most of the functions in this header are simple and self explanatory, such as ptu_go_to() , that sends the gimbal to the provided position. All of these functions are documented in source, so we will not cover most of these. However, there are two functions that simplify certain operations. First, prep_start() will prepare the gimbal for operation. When booting, the gimbal may be in an undesirable state. For example, the axis speed will be zero positions per second, so any move commands will do nothing. This function sets the gimbal to a standard state that will prepare the gimbal for operation. Ideally, this should be executed before any other unit commands. The prep_stop() function does the opposite, it prepares the unit for shutdown. This ensures the gimbal will be in a safe state, and will not move out of this position before the gimbal is powered off. Ideally, this should be the last gimbal operation you preform before shutdown, as any commands issued after this one will not be acknowledged. If you have stopped the gimbal, you may start it again by using the prep_start() method, which will place the gimbal into the initial start state, allowing the gimbal to respond to commands once more. entry The entry.hpp header contains easy to use entry points into the project. It consists of a class, PTUPoint , that will handle starting, stopping, translating, and pointing at certain positions. This class is primarily used in the python wrappers, as it greatly simplifies the binding operation. trans The trans.hpp header contains components for translating positions into gimbal rotations in both axis. We are given positions in North, East, Up coordinates, which are the distance in meters from the origin point in each respective axis. In all cases, we assume the gimbal is the origin of the system. These functions translate these positions into rotations that the gimbal can work with. The details of these functions can be found in the docstrings and the source. You can see entry.cpp for an example of how to use these components.","title":"PTU-SDK"},{"location":"PTU-SDK/#ptu-sdk","text":"PTU-SDK is an SDK provided by FLIR -- with additional utilities/wrappers written by DRIFT -- necessary to control the gimbal. In this documentation, we outline the PTU-SDK works and how to use it.","title":"PTU-SDK"},{"location":"PTU-SDK/#project-stack","text":"This project is written in the C++17 standard, and utilizes the following components: FLiR Base PTU-SDK - The base sdk as provided by FLiR, which facilitates low-level communication with the gimbal FLiR Cerial Library - A networking library used by the base sdk PyBind11 - A library for easily creating python bindings for C++ Python Setuptools - A python build system for creating python modules from this project CMake - Building all components of the sdk clang-tidy - Checks and linting to ensure code quality clang-format - Formatting rules for the project gcc/clang - Either compiler can be utilized depending on developer preference Of these components, CMake, gcc/clang, and Python are REQUIRED for building this project! The rest are either provided with the project, or are optional.","title":"Project Stack"},{"location":"PTU-SDK/#project-structure","text":"This section describes the outline of the project, which includes the physical layout of the project files, CMake build targets, and how components in this project interact.","title":"Project Structure"},{"location":"PTU-SDK/#file-structure","text":"This project has the following outline: PTU-SDK/ \u251c\u2500\u2500 build \u251c\u2500\u2500 dist \u251c\u2500\u2500 docs \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 dptu \u251c\u2500\u2500 libs \u2502 \u2514\u2500\u2500 ptu-sdk \u2502 \u2514\u2500\u2500 cerial \u251c\u2500\u2500 python \u2502 \u2514\u2500\u2500 pdptu \u251c\u2500\u2500 src \u2514\u2500\u2500 utils \u251c\u2500\u2500 drift \u2514\u2500\u2500 sdk-examples Some of these directories will NOT be included in version control, so they may not be present in a fresh clone. All these directories will be auto-generated in one way or another if you preform the operations outlined in the documentation. Directories not included in version control are: build - CMake generated build files, your final build binaries will be placed here when building with CMake! dist - Final Python source distributions / wheels that are built via setuptools The other directories are described below: docs - Contains documentation for this project include - Header files for custom libraries created for this project dptu - header files for the drift PTU sdk src - Source files for custom libraries created for this project python - Python bindings for the drift PTU sdk utils - Development/testing utilities to simplify certain gimbal operations drift - Utilities produced by drift sdk-examples - Utilities provided with the base sdk, these are unaltered libs - External libraries vendored with this project. Required for building any project components ptu-sdk - The provided base sdk, mostly unaltered cerial - 'Cerial' library utilized by the base sdk, mostly unaltered The directories to keep in mind are include/ , src/ , and utils/drift . All others are either automatically generated or are not meant to be changed, as we are striving to keep the provided base components static as much as possible. Any new components and alterations can be be done in the three directories specified most of the time!","title":"File Structure"},{"location":"PTU-SDK/#cmake-structure","text":"This project uses CMake in all build scenarios! All components in this project are CMake enabled, allowing most operations to be done via CMake. This project defines many targets that can be built, but most of the time you only want to focus on a few Below is a outline of the targets, children of a target depends on them: cerial \u2514\u2500\u2500 ptusdk \u251c\u2500\u2500 dptu \u2502 \u251c\u2500\u2500 driftutil \u2502 \u2514\u2500\u2500 pdptu \u2514\u2500\u2500 sdkexamples cerial - Networking library required by the base sdk ptusdk - Provided base sdk library sdkexamples - Builds ALL provided base sdk example binaries, can be executed dptu - DRIFT wrapper library around the base sdk driftutil - Builds ALL DRIFT utility binaries, can be executed pdptu - Python bindings for dptu as a shared library. Building this yourself is usually not required, see the python section","title":"CMake Structure"},{"location":"PTU-SDK/#cmake","text":"As mentioned earlier in this document, this project is build via CMake . It is recommended to handle this process through your IDE, but it is possible to do so manually. Build Steps: Create a build directory: mkdir build Navigate to build directory: cd build/ Invoke CMake to configure the project: cmake .. After the project has been configured, you will see the build directory has been populated with many files! Pretty much all of these can be ignored, but later down the line we will outline some files that are relevant. Build your target: make [TARGET] Where [TARGET] is the name of the target you wish to build. You can see a list of targets above in the CMake Structure section. For example, if you wish to build the dptu target: make dptu Any dependencies will be automatically built for you, so don't worry about building any parents. Locate your build If you are building a library, it will be in format .a for a static library, or .so for a shared library. Unless you are building the python bindings, all libraries built by this project are static, and will have filetype .a . Executables have varying filetypes. On Unix like systems, they will not have a file extension. On Windows, they will have a .exe extension. CMake organizes the build directory in the same way the project is structured. This means it places binaries in locations that are comparable to that of the project. For example, if you build the demo executable, you can find it in: build/utils/drift/demo The same goes for other components, simply follow the directories to locate your binary. Once you have located your binary, you can move it to wherever you like! From there, you can utilize it as you see fit. If you experience any strange errors, or mess up the state of the build system, then you can safely delete the build directory and restart. The build directory does not contain any valuable information! So deleting and reconfiguring has no large consequences, other than the time that is required to re-create and re-build any components.","title":"CMake"},{"location":"PTU-SDK/#python","text":"This project also contains Python bindings that allow this code to be worked with and utilized in Python! This is done via PyBind11 , which greatly simplifies this procedure. PyBind11 is automatically fetched by CMake at configure time, so it is not necessary to install this dependency system wide! Here are the steps to build the python module: First, create a python virtual environment: python -m venv venv/ Activate the virtual environment: source venv/bin/activate Next, install build tools: pip install build Invoke the build system: python -m build From here, it will build your python module and place it into the dist/ directory. This command will create two types of distributions, which we will cover below.","title":"Python"},{"location":"PTU-SDK/#source-distribution","text":"A source distribution is a Python package that contains the files necessary to build your Python module. When asked to install this package, Python will use the contents to build the module for the system it is running on. This is the recommended way to distribute the Python module! It is best to have other developers build the module from scratch on their own systems, instead of having to worry about platform differences and cross-compilation. The downside to this approach is that source distributions require extra time to install on the end of the receiver, as they will need to build the module themselves. This will also require the receiver to have build tools installed, such as CMake and a compiler (gcc/clang), which may be trivial or very difficult to install depending on your platform. Source distributions have extension of type .tar.gz","title":"Source Distribution"},{"location":"PTU-SDK/#wheel-distribution","text":"A so-called 'wheel' is a type of Python package that contains a pre-built module. Wheels are very useful as they do not require a build operation before installing, so any receivers of the wheel can utilize the package immediately and do not require any build tools to be installed. The downside is that the wheel can only be used on the platform it was built on. For example, if a wheel is built on Linux, it is only possible to install and use the wheel on Linux platforms. A windows user could not use such a wheel. While it is possible to cross-build wheels for other platforms, it is not recommended to do so as this introduces a lot of complexity. So, you probably will not be distributing the wheel to others. Wheel distributions have extension of type .whl","title":"Wheel Distribution"},{"location":"PTU-SDK/#development-environment","text":"Developers may work on the project using any tools they like! It is possible to work with this project with nothing more than a text editor, given that you have the requirements satisfied in the tech stack portion of this document. However, this is not recommended, so we will provide a minimum development environment recommendation VSCode is the recommended IDE for this project! It is highly configurable and offers all the features you could want. Any IDE that has support for C++ and CMake would suffice (such as CLion), but we will focus on VSCode in this section. Alongside VSCode, you will want the following extensions: C/C++ - Enables C/C++ Development in VSCode CMake Tools - Adds support for CMake enabled projects Doxygen Generator - Simplifies the process of creating doxygen documentation These extensions are the bare minimum, and it is recommended to install other extensions that enhance your workflow, such as the GitHub integration extension. Alongside these extensions, we suggest the following changes: C_Cpp.codeAnalysis.clangTidy.enabled = true - Enables clang-tidy checks to be preformed by VSCode C_Cpp.codeAnalysis.clangTidy.useBuildPath = true - Instructs clang-tidy to utilize CMake compile-commands.json This will allow VSCode to build and analyze this project for you!","title":"Development Environment"},{"location":"PTU-SDK/#code-components","text":"This section will describe the files that make up this project. Most of the code is already documented in the source! All functions/components have docstrings that describe their usage and behavior, and all code is well commented. However, this section will offer a high level view of the codebase. This project uses the conventional C++ project format, a collection of header files that each have a source file. The header files each contain components that do a specific thing. We will go over each file and go over the broad details: include/ \u2514\u2500\u2500 dptu \u251c\u2500\u2500 comwrap.hpp \u251c\u2500\u2500 entry.hpp \u251c\u2500\u2500 init.hpp \u2514\u2500\u2500 trans.hpp","title":"Code Components"},{"location":"PTU-SDK/#init","text":"The init.hpp header contains components for creating and destroying a 'harness', which is a structure that contains the necessary information for communicating with the gimbal. The nature of this structure will not be discussed here (you may look into the base SDK code if you are curious), as it is not important for gimbal usage. The creation process, done via init_harness() will allocate and configure the harness for operation. The destruction process, done via close_harness() will close the harness and free any memory. It is REQUIRED for all operations to use these methods for creating and destroying the harness! Failing to do either operations can cause bugs and trouble! Most features the DRIFT wrapper provides are optional and can be ignored, but this operation is required!","title":"init"},{"location":"PTU-SDK/#comwrap","text":"The comwrap.hpp header contains components for wrapping certain SDK operations. The procedure for sending a command to the gimbal via the base sdk is somewhat complicated and weird. So, one of the major goals of this project is to simplify operations and this header defines components that do just that. Most of the functions in this header are simple and self explanatory, such as ptu_go_to() , that sends the gimbal to the provided position. All of these functions are documented in source, so we will not cover most of these. However, there are two functions that simplify certain operations. First, prep_start() will prepare the gimbal for operation. When booting, the gimbal may be in an undesirable state. For example, the axis speed will be zero positions per second, so any move commands will do nothing. This function sets the gimbal to a standard state that will prepare the gimbal for operation. Ideally, this should be executed before any other unit commands. The prep_stop() function does the opposite, it prepares the unit for shutdown. This ensures the gimbal will be in a safe state, and will not move out of this position before the gimbal is powered off. Ideally, this should be the last gimbal operation you preform before shutdown, as any commands issued after this one will not be acknowledged. If you have stopped the gimbal, you may start it again by using the prep_start() method, which will place the gimbal into the initial start state, allowing the gimbal to respond to commands once more.","title":"comwrap"},{"location":"PTU-SDK/#entry","text":"The entry.hpp header contains easy to use entry points into the project. It consists of a class, PTUPoint , that will handle starting, stopping, translating, and pointing at certain positions. This class is primarily used in the python wrappers, as it greatly simplifies the binding operation.","title":"entry"},{"location":"PTU-SDK/#trans","text":"The trans.hpp header contains components for translating positions into gimbal rotations in both axis. We are given positions in North, East, Up coordinates, which are the distance in meters from the origin point in each respective axis. In all cases, we assume the gimbal is the origin of the system. These functions translate these positions into rotations that the gimbal can work with. The details of these functions can be found in the docstrings and the source. You can see entry.cpp for an example of how to use these components.","title":"trans"},{"location":"about/","text":"Nosces inornatos victori Se roganda minimas donec inducere videntur Lorem markdownum, esses caelitibus viro. Opus nare bimari media explicat excidit usque. Tui par equique Aetne, reccidat a margine ignibus miracula numen nec talibus carmine tristisque. Victum vero meruisse arvis exegit quare cum haesit, at fronde scelus. Nostroque dicenti causas et cinxit primusque dolor Laetaris indoluit concordare cruentior inde quo iam tum quater, humi est! Fidis sed ardent, Nileus aeque carpentem et orbes. Et sorori quoque ferro manibus carchesia dedit: agmina pariente sublimis auctor. Vocisque laniger audet Romana aures Manu infans praebet cladis ferrumque cervus: gravis mea posita vero, pars niveum, terreat caelo agna mille. Est oculosque coagula memorque, modo Troades fetus si glacialis elisarum, nullis sine fumantiaque esse. Una solet et fuit est fuit pluma sic prodes marem odit Eurynomus mensis; qui. if (minimize_technology_kilobit + command(-4, ergonomics_intranet_core)) { textRwSnow = grayscaleAppFrozen + kvm(-5, 2, sdRemoteFavorites); } else { spiderLeftPop = 4; username_port(3); } var port_sd = host(box_syn.leopard_point(terahertzIos(wins), truncate_mips, noc_drm), 1, mount_function(-4)); capacityFlash = net_only(host_trackball, tcp_website, disk) + atm_io_primary; if (cachePciOs < 11) { bluSoftwarePretest *= 4; optic_infotainment(parallel_search, ribbon_rj / 2); } Amato coniunctaque victa Luctantemque procul adversae quarum at concussit ignis fraternis Cecropio est, dies imagine, non cantus admota tener! Terra est illuc sedit: et sed fui convertit ille , capillos, ut fruges, sed Saturnia Taenarides. Esse est, esse, funes aere inclinat, leones cogit inprobat domoque arbore fere. Numina quae: geminae: si dumque oritur circumspice tolles arbitrium tempora pinus. Tollit quem se tamen videt hunc curam Nec urguent ignotas perluitur patris Curvos iam vapor aequore resupino Sidus falsi venenis pressistis madida Iovis Se ultor pedibusve sumptis Pylos et manuque Pars ambae: nec quam veneni, videri increpat hominum utque, ait est Olympi gerit. Muneris propiora candida. Faciendo deus; devia notare, quae dentes socerque. Loco luctu huic etiam hausit et carmina, saepe magna nec. Nobiscum laudemque externis venatu Phoeboque, et nobis rami omen Ericthonium color attonitum pecudes in meruisse confundere vidit. Iam antrum de in, nec sanguine, iram Phoebeamque iura.","title":"Nosces inornatos victori"},{"location":"about/#nosces-inornatos-victori","text":"","title":"Nosces inornatos victori"},{"location":"about/#se-roganda-minimas-donec-inducere-videntur","text":"Lorem markdownum, esses caelitibus viro. Opus nare bimari media explicat excidit usque. Tui par equique Aetne, reccidat a margine ignibus miracula numen nec talibus carmine tristisque. Victum vero meruisse arvis exegit quare cum haesit, at fronde scelus.","title":"Se roganda minimas donec inducere videntur"},{"location":"about/#nostroque-dicenti-causas-et-cinxit-primusque-dolor","text":"Laetaris indoluit concordare cruentior inde quo iam tum quater, humi est! Fidis sed ardent, Nileus aeque carpentem et orbes. Et sorori quoque ferro manibus carchesia dedit: agmina pariente sublimis auctor.","title":"Nostroque dicenti causas et cinxit primusque dolor"},{"location":"about/#vocisque-laniger-audet-romana-aures","text":"Manu infans praebet cladis ferrumque cervus: gravis mea posita vero, pars niveum, terreat caelo agna mille. Est oculosque coagula memorque, modo Troades fetus si glacialis elisarum, nullis sine fumantiaque esse. Una solet et fuit est fuit pluma sic prodes marem odit Eurynomus mensis; qui. if (minimize_technology_kilobit + command(-4, ergonomics_intranet_core)) { textRwSnow = grayscaleAppFrozen + kvm(-5, 2, sdRemoteFavorites); } else { spiderLeftPop = 4; username_port(3); } var port_sd = host(box_syn.leopard_point(terahertzIos(wins), truncate_mips, noc_drm), 1, mount_function(-4)); capacityFlash = net_only(host_trackball, tcp_website, disk) + atm_io_primary; if (cachePciOs < 11) { bluSoftwarePretest *= 4; optic_infotainment(parallel_search, ribbon_rj / 2); }","title":"Vocisque laniger audet Romana aures"},{"location":"about/#amato-coniunctaque-victa","text":"Luctantemque procul adversae quarum at concussit ignis fraternis Cecropio est, dies imagine, non cantus admota tener! Terra est illuc sedit: et sed fui convertit ille , capillos, ut fruges, sed Saturnia Taenarides. Esse est, esse, funes aere inclinat, leones cogit inprobat domoque arbore fere. Numina quae: geminae: si dumque oritur circumspice tolles arbitrium tempora pinus. Tollit quem se tamen videt hunc curam Nec urguent ignotas perluitur patris Curvos iam vapor aequore resupino Sidus falsi venenis pressistis madida Iovis","title":"Amato coniunctaque victa"},{"location":"about/#se-ultor-pedibusve-sumptis-pylos-et-manuque","text":"Pars ambae: nec quam veneni, videri increpat hominum utque, ait est Olympi gerit. Muneris propiora candida. Faciendo deus; devia notare, quae dentes socerque. Loco luctu huic etiam hausit et carmina, saepe magna nec. Nobiscum laudemque externis venatu Phoeboque, et nobis rami omen Ericthonium color attonitum pecudes in meruisse confundere vidit. Iam antrum de in, nec sanguine, iram Phoebeamque iura.","title":"Se ultor pedibusve sumptis Pylos et manuque"},{"location":"ardupilot-logs-parsing/","text":"Ardupilot Logs Parsing Work in progress.","title":"Ardupilot Logs Parsing"},{"location":"ardupilot-logs-parsing/#ardupilot-logs-parsing","text":"Work in progress.","title":"Ardupilot Logs Parsing"},{"location":"kinematic-model/","text":"Kinematic Model of a Moving Drone's Telemetry Stream This notebook represents a kinematic model of telemetry data from a moving drone. A kinematic model describes the movement of objects using variables such as position, velocity, and acceleration, without considering the underlying forces that cause the motion. In this case, we are predicting the next position of the drone based on its current position and velocity. Methodology Data Preprocessing The first step of the notebook is the data preprocessing, where the mavlink data of the drone and the ground control station (GCS) are loaded. We add a prefix to their packet type to be easily identified (UAV_/GCS_). The time_boot_ms column which provides the system time since boot, is normalized by the minimum time to start the timestamp from zero. All of them are then combined into one dataframe, sorted by time in ascending order, and some columns are converted into their correct units. Conversion to East, North, Up (ENU) coordinates In the field of aerial vehicles, including drones, a common coordinate system used is the East, North, Up (ENU) system. In this system: The x-axis points towards the North. The y-axis points towards the East. The z-axis points Upwards. To transform the GPS (latitude, longitude, altitude) coordinates into ENU, we use the geodetic2enu function from the pymap3d library. The conversion needs a reference point, which is in this case the starting point of the drone. \u26a0\ufe0f E, N, U is not in the same order as X, Y, Z. The result of pymap3d.geodetic2enu() must be unpacked like y, x, z = pymap3d.geodetic2enu() Kinematic Prediction To predict the position of the drone in the next timestamp, we use a basic kinematic equation: position_next = position_current + velocity_current * time_to_next Where time_to_next is the difference in time between two consecutive timestamps. This equation assumes that the drone moves at a constant velocity, thus it's a simple approximation that does not consider any changes in velocity (acceleration). In this example, we are forecasting the drone's location for the upcoming timestamp. This allows us to compare our prediction with the actual reported location at that subsequent timestamp. Evaluation The predictions are evaluated by calculating the Euclidean distance between the predicted and actual positions. The Euclidean distance between two points in 3D space is calculated as follows: distance = sqrt((x1-x2)^2 + (y1-y2)^2 + (z1-z2)^2) The distances are then converted into centimeters and visualized by a histogram. What these distances mean The distances calculated in this model represent the adjustments anticipated in real-time drone operations. Specifically, the gimbal on the drone will follow each predicted vector until it reaches the predicted location. Then it will need to \"jump\" to the next actual reported location. These 'jumps' are represented by the distances we have calculated. Assuming that the reported locations are completely accurate, these distances provide a good estimation of the potential error expected in the model. They could be used to inform the design parameters of the receiving device on the drone. However, it's important to consider some degree of error in the reported location data itself. Additionally, the mechanical inaccuracies or latency in the drone's pan-tilt unit can also contribute to the overall model error. Therefore, due to the combined implications of location data inaccuracies and the mechanical response of the drone's pan-tilt unit, the calculated error should not be solely used to determine the design requirements of the receiving device on the drone. Visualization Although drone motion in 3D space is best visualized with a 3D plot, 2D plots might be more convenient in some situations. Thus, both 3D and 2D plots are made, where each point corresponds to a timestamp, and a line is drawn to the point that represents the predicted position for the next timestamp. Fourier Transform Analysis I used the Fourier Transform as a tool to analyze the inconsistency in the vertical velocity ('vz') of the drone. Initially, the error in the z-direction of the drone movement wasn't making sense, so I used the spectral analysis to examine the dominant frequencies that make up the 'vz' signal. On plotting these frequencies, I noticed a significant spike at approximately 1.2Hz. Interestingly, this dominant frequency at 1.2Hz matched the frequency observed from my smartphone's accelerometer while I was walking with the drone. In essence, the Fourier Transform helped me realize that the drone's vertical velocity was significantly influenced by my walking rhythm.","title":"Kinematic Model"},{"location":"kinematic-model/#kinematic-model-of-a-moving-drones-telemetry-stream","text":"This notebook represents a kinematic model of telemetry data from a moving drone. A kinematic model describes the movement of objects using variables such as position, velocity, and acceleration, without considering the underlying forces that cause the motion. In this case, we are predicting the next position of the drone based on its current position and velocity.","title":"Kinematic Model of a Moving Drone's Telemetry Stream"},{"location":"kinematic-model/#methodology","text":"","title":"Methodology"},{"location":"kinematic-model/#data-preprocessing","text":"The first step of the notebook is the data preprocessing, where the mavlink data of the drone and the ground control station (GCS) are loaded. We add a prefix to their packet type to be easily identified (UAV_/GCS_). The time_boot_ms column which provides the system time since boot, is normalized by the minimum time to start the timestamp from zero. All of them are then combined into one dataframe, sorted by time in ascending order, and some columns are converted into their correct units.","title":"Data Preprocessing"},{"location":"kinematic-model/#conversion-to-east-north-up-enu-coordinates","text":"In the field of aerial vehicles, including drones, a common coordinate system used is the East, North, Up (ENU) system. In this system: The x-axis points towards the North. The y-axis points towards the East. The z-axis points Upwards. To transform the GPS (latitude, longitude, altitude) coordinates into ENU, we use the geodetic2enu function from the pymap3d library. The conversion needs a reference point, which is in this case the starting point of the drone. \u26a0\ufe0f E, N, U is not in the same order as X, Y, Z. The result of pymap3d.geodetic2enu() must be unpacked like y, x, z = pymap3d.geodetic2enu()","title":"Conversion to East, North, Up (ENU) coordinates"},{"location":"kinematic-model/#kinematic-prediction","text":"To predict the position of the drone in the next timestamp, we use a basic kinematic equation: position_next = position_current + velocity_current * time_to_next Where time_to_next is the difference in time between two consecutive timestamps. This equation assumes that the drone moves at a constant velocity, thus it's a simple approximation that does not consider any changes in velocity (acceleration). In this example, we are forecasting the drone's location for the upcoming timestamp. This allows us to compare our prediction with the actual reported location at that subsequent timestamp.","title":"Kinematic Prediction"},{"location":"kinematic-model/#evaluation","text":"The predictions are evaluated by calculating the Euclidean distance between the predicted and actual positions. The Euclidean distance between two points in 3D space is calculated as follows: distance = sqrt((x1-x2)^2 + (y1-y2)^2 + (z1-z2)^2) The distances are then converted into centimeters and visualized by a histogram.","title":"Evaluation"},{"location":"kinematic-model/#what-these-distances-mean","text":"The distances calculated in this model represent the adjustments anticipated in real-time drone operations. Specifically, the gimbal on the drone will follow each predicted vector until it reaches the predicted location. Then it will need to \"jump\" to the next actual reported location. These 'jumps' are represented by the distances we have calculated. Assuming that the reported locations are completely accurate, these distances provide a good estimation of the potential error expected in the model. They could be used to inform the design parameters of the receiving device on the drone. However, it's important to consider some degree of error in the reported location data itself. Additionally, the mechanical inaccuracies or latency in the drone's pan-tilt unit can also contribute to the overall model error. Therefore, due to the combined implications of location data inaccuracies and the mechanical response of the drone's pan-tilt unit, the calculated error should not be solely used to determine the design requirements of the receiving device on the drone.","title":"What these distances mean"},{"location":"kinematic-model/#visualization","text":"Although drone motion in 3D space is best visualized with a 3D plot, 2D plots might be more convenient in some situations. Thus, both 3D and 2D plots are made, where each point corresponds to a timestamp, and a line is drawn to the point that represents the predicted position for the next timestamp.","title":"Visualization"},{"location":"kinematic-model/#fourier-transform-analysis","text":"I used the Fourier Transform as a tool to analyze the inconsistency in the vertical velocity ('vz') of the drone. Initially, the error in the z-direction of the drone movement wasn't making sense, so I used the spectral analysis to examine the dominant frequencies that make up the 'vz' signal. On plotting these frequencies, I noticed a significant spike at approximately 1.2Hz. Interestingly, this dominant frequency at 1.2Hz matched the frequency observed from my smartphone's accelerometer while I was walking with the drone. In essence, the Fourier Transform helped me realize that the drone's vertical velocity was significantly influenced by my walking rhythm.","title":"Fourier Transform Analysis"},{"location":"telemetry-stream/","text":"Telemetry Stream telemetry-stream is responsible for streaming telemetry data from the drone we are tracking to our kinematic-model which will then perform the necessary calculations needed by PTU-SDK to move the gimbal controlling the laser. In this documentation, we outline how telemetry-stream works and how to use it.","title":"Telemetry Stream"},{"location":"telemetry-stream/#telemetry-stream","text":"telemetry-stream is responsible for streaming telemetry data from the drone we are tracking to our kinematic-model which will then perform the necessary calculations needed by PTU-SDK to move the gimbal controlling the laser. In this documentation, we outline how telemetry-stream works and how to use it.","title":"Telemetry Stream"}]}